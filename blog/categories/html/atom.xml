<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: HTML | TJ VanToll]]></title>
  <link href="http://tjvantoll.com/blog/categories/html/atom.xml" rel="self"/>
  <link href="http://tjvantoll.com/"/>
  <updated>2014-05-12T13:57:20-04:00</updated>
  <id>http://tjvantoll.com/</id>
  <author>
    <name><![CDATA[TJ VanToll]]></name>
    <email><![CDATA[tj.vantoll@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Semantic HTML to Drive Display Logic]]></title>
    <link href="http://tjvantoll.com/2014/05/01/using-semantic-html-to-drive-display-logic/"/>
    <updated>2014-05-01T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2014/05/01/using-semantic-html-to-drive-display-logic</id>
    <content type="html"><![CDATA[<p>Today I want to share a quick tip for driving display logic in UI components—and I think it's easier to see in an example.</p>

<p>Suppose you are tasked with implementing a form that can be used by two types of users: admins and regular users. Admins should be able to delete, and regular users should see an informational message. The display of this form is shown below:</p>

<p><img src="http://tjvantoll.com/images/posts/2014-05-01/user-types.png" alt="Display of the admin and regular user modes of a form"></p>

<p><em>Note: You can view the final example of this code at <a href="http://jsfiddle.net/tj_vantoll/77TbG/">http://jsfiddle.net/tj_vantoll/77TbG/</a> if you'd like to follow along.</em></p>

<!--more-->


<p>Here's the HTML we'll use:</p>

<p>``` html
<form id="information-form"></p>

<pre><code>&lt;fieldset&gt;
    &lt;legend&gt;Information&lt;/legend&gt;
    &lt;div&gt;
        &lt;label for="name"&gt;Name:&lt;/label&gt;
        &lt;input id="name"&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for="address"&gt;Address:&lt;/label&gt;
        &lt;input id="address"&gt;
    &lt;/div&gt;

    &lt;button&gt;Update&lt;/button&gt;
    &lt;button id="delete"&gt;Delete&lt;/button&gt;

    &lt;p id="admin-message"&gt;To delete this user, please contact an administrator.&lt;/p&gt;
&lt;/fieldset&gt;
</code></pre>

<p></form>
```</p>

<p>And we'll use two buttons to switch between the two user types.</p>

<p><code>html
&lt;button id="admin"&gt;Display as admin&lt;/button&gt;
&lt;button id="regular-user"&gt;Display as regular user&lt;/button&gt;
</code></p>

<p>So, the question is... what JavaScript do you implement to show/hide the delete button and informational message? The following shows an approach I often see: targeting individual elements in JavaScript, and altering their display.</p>

<p>``` javascript
var adminButton = document.querySelector( "#admin" ),</p>

<pre><code>regularButton = document.querySelector( "#regular-user" ),
deleteButton = document.querySelector( "#delete" ),
adminMessage = document.querySelector( "#admin-message" );
</code></pre>

<p>adminButton.addEventListener( "click", function() {</p>

<pre><code>deleteButton.style.display = "inline-block";
adminMessage.style.display = "none";
</code></pre>

<p>});
regularButton.addEventListener( "click", function() {</p>

<pre><code>deleteButton.style.display = "none";
adminMessage.style.display = "block";
</code></pre>

<p>});
```</p>

<p>This works, but it's verbose, as you have to target each element that should be shown or hidden whenever the user types changes. From a more abstract perspective, it also breaks the <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns design principle</a>, since CSS changes are being done in JavaScript.</p>

<p>To improve this, let's switch the JavaScript to manage a single CSS class name on the form.</p>

<p>``` javascript
var adminButton = document.querySelector( "#admin" ),</p>

<pre><code>regularButton = document.querySelector( "#regular-user" ),
form = document.querySelector( "#information-form" );
</code></pre>

<p>adminButton.addEventListener( "click", function() {</p>

<pre><code>form.classList.add( "admin" );
</code></pre>

<p>});
regularButton.addEventListener( "click", function() {</p>

<pre><code>form.classList.remove( "admin" );
</code></pre>

<p>});
```</p>

<p>At the moment, nothing shows or hides when you click buttons, but with the <code>"admin"</code> class name in place, you have the hook you need to implement the logic in CSS.</p>

<p>``` css</p>

<h1>delete {</h1>

<pre><code>display: none;
</code></pre>

<p>}
.admin #admin-message {</p>

<pre><code>display: none;
</code></pre>

<p>}
.admin #delete {</p>

<pre><code>display: inline-block;
</code></pre>

<p>}
```</p>

<p>JavaScript manages the state of the element, which gives CSS the ability to control the display based on that state. This approach is not only cleaner, it is also more flexible. If you need to change colors for admin, or spacing, you now have a CSS hook you can use to do so.</p>

<p>This same approach works with HTML attributes as well. For instance, let's switch from using a CSS class name, to a <code>data-admin</code> attribute on the <code>&lt;form&gt;</code>. With that approach you use the following JavaScript:</p>

<p>``` javascript
var adminButton = document.querySelector( "#admin" ),</p>

<pre><code>regularButton = document.querySelector( "#regular-user" ),
form = document.querySelector( "#information-form" );
</code></pre>

<p>adminButton.addEventListener( "click", function() {</p>

<pre><code>form.setAttribute( "data-admin", true );
</code></pre>

<p>});
regularButton.addEventListener( "click", function() {</p>

<pre><code>form.setAttribute( "data-admin", false );
</code></pre>

<p>});
```</p>

<p>And the following CSS:</p>

<p>``` css</p>

<h1>delete {</h1>

<pre><code>display: none;
</code></pre>

<p>}
[data-admin="true"] #admin-message {</p>

<pre><code>display: none;
</code></pre>

<p>}
[data-admin="true"] #delete {</p>

<pre><code>display: inline-block;
</code></pre>

<p>}
```</p>

<p>Use whatever makes sense for your use case. The overarching idea is to use JavaScript to apply semantic HTML that reflects an element's state, and to let CSS control the display from there. Personally I've found this to be the best way to handle display logic in UI components—especially complex ones.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effect of iOS 7.1's minimal-ui Viewport Property]]></title>
    <link href="http://tjvantoll.com/2014/03/11/effect-of-ios-7-dot-1s-minimal-ui-meta-tag/"/>
    <updated>2014-03-11T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2014/03/11/effect-of-ios-7-dot-1s-minimal-ui-meta-tag</id>
    <content type="html"><![CDATA[<p>One of the major, and <a href="http://www.mobilexweb.com/blog/safari-ios7-html5-problems-apis-review">not well-received</a> changes introduced in iOS7 was the lack of a true full screen mode. Apple's answer was the introduction of a <code>minimal-ui</code> viewport property in iOS 7.1, which was released yesterday.</p>

<p>I wanted to quickly show the effect this property has. Adding it is as easy as appending <code>minimal-ui</code> to the <code>content</code> attribute of your site's <code>&lt;meta&gt;</code> tag.</p>

<p><code>html
&lt;meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui"&gt;
</code></p>

<p>The two images below show a before and after of applying the property to a test page.</p>

<p><img src="/images/posts/2014-03-11/before.png" alt="Without minimal-ui property status bars display" />
<img src="/images/posts/2014-03-11/after.png" alt="With minimal-ui status bars do not show" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Is Styling Form Elements So Damn Hard?]]></title>
    <link href="http://tjvantoll.com/2013/12/06/why-is-styling-form-elements-so-damn-hard/"/>
    <updated>2013-12-06T12:54:00-05:00</updated>
    <id>http://tjvantoll.com/2013/12/06/why-is-styling-form-elements-so-damn-hard</id>
    <content type="html"><![CDATA[<p>The web has come a long way. We can now build powerful 3D animations, design sites that work on a vast array of screen sizes, and even <a href="https://brendaneich.com/2013/03/the-web-is-the-game-platform/">play high end games</a> - all without leaving our browser.</p>

<p>Despite this, developers still cannot change the background color of an <code>&lt;option&gt;</code> or the size of a checkbox. Why is this?</p>

<p>Basically, it comes down to the fact that the HTML specification dictates how form controls should <em>function</em>, and not how they should look. Therefore UAs (User Agents, aka browsers) are free to come up with a UI they feel best performs the functionality. And as such, there are vast differences in the UIs used.</p>

<p>Giving browsers control over the display of form controls has had an enormous impact on the development of the web - good and bad. Let's discuss the good first.</p>

<!--more-->


<h3>Why Letting Browser Control Form Elements is Awesome</h3>

<p>To start our discussion, consider this simple <code>&lt;select&gt;</code> element.</p>

<p>``` html
<select></p>

<pre><code>&lt;option&gt;One&lt;/option&gt;
&lt;option&gt;Two&lt;/option&gt;
&lt;option&gt;Three&lt;/option&gt;
</code></pre>

<p></select>
```</p>

<p>Here's a sampling of a few different renderings. The two on the left are Chrome and Firefox for OS X, the two on the right are IE and Chrome for Windows.</p>

<p><img src="http://tjvantoll.com/images/posts/2013-12-06/selects.png" alt="View of selects on multiple platforms"></p>

<p>While there are slightly different approaches here, these controls look relatively the same. However, the story is completely different when you consider mobile devices. The image below shows the <code>&lt;select&gt;</code> rendering on some common mobile OSs (Android on the left, iOS on the right).</p>

<p><img src="http://tjvantoll.com/images/posts/2013-12-06/selects-mobile.png" alt="View of selects on multiple platforms"></p>

<p>Because mobile browsers are not locked down to specific displays, they are free to present <code>&lt;select&gt;</code> menus in a way that best fits the device they're running on. This is the single greatest advantage of giving browsers complete control over the look of form controls. Just think of how horrible an experience working with desktop sized <code>&lt;select&gt;</code> menus would be on a mobile device.</p>

<p>Furthermore, browsers can present users with familiar OS controls. As an example, iOS uses the same datepicker for <code>&lt;input type="date"&gt;</code> as it does for its calendar app. This familiarity helps users complete forms quicker.</p>

<p>While these truly custom UIs are great for mobile users, they present a major issue for developers.</p>

<h3>Why Letting Browser Control Form Elements is Horrible</h3>

<p>Because we now have a multitude of ways form controls are displayed, it is literally impossible to control the look, feel, and positioning of these controls across platforms. If you consider all the <code>&lt;select&gt;</code> renderings shown above, what would applying a <code>padding</code> or <code>margin</code> to an <code>&lt;option&gt;</code> element even mean?</p>

<p>This is a problem, because making slight alterations to form controls is a common request web developers have. As such, the question of how to address this has been going around the <a href="http://www.whatwg.org/mailing-list#specs">WHATWG mailing list</a> and <a href="http://lists.w3.org/">W3C mailing list</a> recently.</p>

<p>There are a number of ideas being thrown out there, so I thought I'd summarize a few of them.</p>

<h3>Pseudo Elements</h3>

<p>A number of browsers now offer styling hooks through vendor prefixed pseudo elements. (I created a <a href="/2013/12/06/why-is-styling-form-elements-so-damn-hard/">full list</a> if you'd like to peruse them). For instance <code>::-ms-check</code> lets you play with the look of checkboxes and radio buttons in IE.</p>

<p>``` html</p>



<p><input type="checkbox">
<input type="radio">
```</p>

<p>Which renders as follows.</p>

<p><img src="http://tjvantoll.com/images/posts/2013-04-15/trident-radio-checkbox.png" alt="Display of altered checkboxes in IE"></p>

<p>For the specification, the idea is that we could standardize all of the common styling points. So <code>::check</code> would be able to style checkboxes and radio buttons on all platforms, not just IE. And since the shadow DOM spec includes a <a href="http://www.w3.org/TR/shadow-dom/#custom-pseudo-elements">mechanism for exposing custom pseudo-elements</a>, this seems like a perfect solution.</p>

<p>While this sounds great, there are two fundamental problems.</p>

<p><strong>1)</strong> Because of mobile, there is almost nothing in common with the look of <em>any</em> form control across all platforms. For instance, a common request of developers is the ability to customize the calendar presented by <code>&lt;input type="date"&gt;</code>, however consider the display of the calendar on just the three platforms shown below.</p>

<p><img src="http://tjvantoll.com/images/posts/2013-12-06/calendars.png" alt="Display of date input on Chrome, iOS, and Chrome for Android"></p>

<p>Even if you wanted to standardize something, what would it be?</p>

<p><strong>2)</strong> By standardizing pseudo elements you limit the flexibility currently afforded to browsers to innovate. IE's <code>::-ms-check</code> pseudo-element is actually a perfect example of this. If <code>::check</code> were indeed standardized, it would prevent browsers from using a completely different representation of a checkbox, such as an iOS style switch (unless they violated the spec).</p>

<p>Therefore while this solution seems appealing, it doesn't appear to be a complete solution to styling form controls on the web.</p>

<h3>Using Shadow DOM</h3>

<p>The <a href="http://www.w3.org/TR/shadow-dom/">shadow DOM</a> specification has made another - more drastic - solution possible. Since browsers internally implement form elements through shadow DOM, you have the ability to inject your own shadow root to use instead of the browser's.</p>

<p>And as of Chrome 31, this is now something you can actually do. The following example creates a native <code>&lt;input type="date"&gt;</code>, gives it a new shadow root to use, and implements the calendar using <a href="http://jqueryui.com/datepicker/">jQuery UI's datepicker</a>.</p>

<p>``` html</p>



<p><input type="date"></p>

<script>
    var dateRoot = document.querySelector( "input" )
        .webkitCreateShadowRoot();

    $( "input" ).datepicker({
        dateFormat: "yy-mm-dd",
        onSelect: function( dateText ) {
            dateRoot.innerHTML = dateText;
        }
    });
</script>


<p>```</p>

<p>And here's the example live, although you need Chrome 31+ for it to actually work.</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/tj_vantoll/6qadQ/embedded/result,html,js,css" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>You may notice that there is one big issue with this example. While we do get a custom datepicker, we lose the <code>&lt;input&gt;</code> behavior, including the ability to type in a value.</p>

<p>Another downside is this uses the JavaScript based calendar on all platforms - even mobile ones. Therefore if you try run this example on Chrome for Android you get the jQuery UI's calendar rather than the more mobile friendly calendar most developers want.</p>

<h3>Moving Forward</h3>

<p>How do we move forward and make form controls on the web styleable?</p>

<p>Standardizing pseudo elements seems attractive because they're easy to use. Who wants to create a new shadow root for an element just to change a few colors? The large number of platform differences makes challenging, but it may be possible for simple elements.</p>

<p>Using shadow roots has potential. While it's a bit of work, the really hard stuff could be abstracted into libraries. The problem is currently we have no good way of inheriting the basic functionality of an <code>&lt;input&gt;</code>, and reinventing the wheel in an accessible way is challenging.</p>

<p>As developers we want some magical solution where we can make style the desktop based controls and somehow leave mobile ones alone. And unfortunately this is a very hard problem to solve.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using jQuery UI Tabs with the &lt;base&gt; Tag]]></title>
    <link href="http://tjvantoll.com/2013/02/17/using-jquery-ui-tabs-with-the-base-tag/"/>
    <updated>2013-02-17T21:14:00-05:00</updated>
    <id>http://tjvantoll.com/2013/02/17/using-jquery-ui-tabs-with-the-base-tag</id>
    <content type="html"><![CDATA[<p>As there have been <a href="http://bugs.jqueryui.com/ticket/7822">numerous bug submissions</a> for this, I feel the need to explain how to properly use <a href="http://jqueryui.com/tabs">jQuery UI's tab widget</a> with a <code>&lt;base&gt;</code> tag.  Let's start with what the <code>&lt;base&gt;</code> tag is intended for.</p>

<h3>The &lt;base&gt; Element</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/HTML/Element/base">Per MDN</a> the <code>&lt;base&gt;</code> element specifies the base URL to use for all relative URLs contained within a document.</p>

<!--more-->


<p>Consider the following example:</p>

<p><code>html
&lt;base href="http://foo.com"&gt;
&lt;a href="bar.html"&gt;Bar&lt;/a&gt;
</code></p>

<p>Let's assume this HTML appears on this domain (<code>http://tjvantoll.com</code>).  When the link is clicked on, the browser will navigate to <code>http://foo.com/bar.html</code> rather than <code>http://tjvantoll.com/bar.html</code>.</p>

<p>It's important to note that hash links are also relative to the specified base.  Therefore on the following:</p>

<p><code>html
&lt;base href="http://foo.com"&gt;
&lt;a href="#bar"&gt;Bar&lt;/a&gt;
</code></p>

<p>When the link is click on, the browser will navigate to <code>http://foo.com#bar</code> and NOT <code>http://tjvantoll.com#bar</code>.  This detail is important; it's the root cause of confusion when using a <code>&lt;base&gt;</code> tag with the tabs widget.</p>

<h3>jQuery UI Tabs</h3>

<p>Here is the intended HTML structure to be used by the tabs widget:</p>

<p>``` html</p>

<div id="tabs">
    <ul>
        <li><a href="#tab-1">One</a></li>
        <li><a href="#tab-2">Two</a></li>
    </ul>
    <div id="tab-1">Contents of tab one.</div>
    <div id="tab-2">Contents of tab two.</div>
</div>




<script>$( "#tabs" ).tabs();</script>


<p>```</p>

<p>Which produces the following:</p>

<p><img src="http://tjvantoll.com/images/posts/2013-02-17/tabs.png" alt="Default look of jQuery UI's tabs"></p>

<p>In this example both links begin with a hash (<code>#</code>), indicating that their content is located on the current page.  If that is not the case, the tabs widget will retrieve the tab's contents server side via an XHR call.  Consider the following:</p>

<p>``` html</p>

<div id="tabs">
    <ul>
        <li><a href="#local">Local</a></li>
        <li><a href="external">External</a></li>
    </ul>
    <div id="local">Contents of the local tab.</div>
</div>




<script>$( "#tabs" ).tabs();</script>


<p>```</p>

<p>Here the local link will work as in the previous example - when it is clicked on, the tabs widget will simply display the contents of the <code>#local</code> container.</p>

<p>However, when the external link is clicked, the tabs widget will perform an XHR request to retrieve the contents.  Assuming this HTML is located on <code>http://tjvantoll.com</code>, an XHR GET will be performed for <code>http://tjvantoll.com/external</code>.  The contents returned are dynamically added to the DOM and displayed.</p>

<p>The markup pattern used here is no accident.  Consider a user that views this HTML without JavaScript enabled.  The local link will move the user's focus to the <code>#local</code> container on <code>http://tjvantoll.com</code>.  The external link will do a full page navigation to <code>http://tjvantoll.com/external</code>.  The markup is designed to enhance the default browser behavior and to degrade gracefully when JavaScript isn't present.</p>

<h3>&lt;base&gt; + tabs</h3>

<p>Given the descriptions above, the behavior of the <code>&lt;base&gt;</code> tag with the tabs widget shouldn't be surprising.  Here's the first example given for the tabs widget again.  This time, a <code>&lt;base&gt;</code> tag to <code>http://foo.com</code> has been added:</p>

<p>``` html
<base href="http://foo.com"></p>

<div id="tabs">
    <ul>
        <li><a href="#tab-1">One</a></li>
        <li><a href="#tab-2">Two</a></li>
    </ul>
    <div id="tab-1">Contents of tab one.</div>
    <div id="tab-2">Contents of tab two.</div>
</div>




<script>$( "#tabs" ).tabs();</script>


<p>```</p>

<p>Let's again assume this HTML is located on <code>http://tjvantoll.com</code>.  Because of the <code>&lt;base&gt;</code> tag, the links used in the tabs widget are actually external links to <code>http://foo.com</code>.  Therefore, upon instantiation, the tabs widget will attempt to load the contents of the first tab from <code>http://foo.com</code>.</p>

<p>If you are having trouble understanding, try the example above with JavaScript disabled.  When the first link is clicked on, the browser will navigate to <code>http://foo.com</code> regardless of the domain the page is viewed on.</p>

<h3>Fixes</h3>

<p>From the numerous bug reports, it seems that a lot of people have applications with <code>&lt;base&gt;</code> tags and want hashed links to be relative to the current page.  How can you fix your application?</p>

<p>1) <strong>Remove the <code>&lt;base&gt;</code> tag.</strong>  It's that simple.  After the removal, the tabs widget will never attempt to load external content from any links with leading hashes.  Of course, this approach requires changing any other links on the page that are dependent on the <code>&lt;base&gt;</code> tag's leading path.</p>

<p>2) <strong>Provide full URLs on links used to build the tabs widget.</strong>  If approach #1 isn't feasible, you can also provide a fully qualified URL in the links used to build the tabs widget.  Here's the earlier example modified to show this approach:</p>

<p>``` html
<base href="http://foo.com"></p>

<div id="tabs">
    <ul>
        <li><a href="http://tjvantoll.com#tab-1">One</a></li>
        <li><a href="http://tjvantoll.com#tab-2">Two</a></li>
    </ul>
    <div id="tab-1">Contents of tab one.</div>
    <div id="tab-2">Contents of tab two.</div>
</div>




<script>$( "#tabs" ).tabs();</script>


<p>```</p>

<p>Since the links in the tabs are now fully qualified paths to the current page, the tabs widget will not perform a request to retrieve external content.</p>

<p>A more robust way of handling this would be to inject the current path server side.  For example the following PHP could be used to inject the link used in the first tab above:</p>

<p><code>'http://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'] . '#tab-1'</code></p>

<p>3) <strong>Add the full URLs via JavaScript.</strong></p>

<div class="warning" style="display: block;">
    This is not the right way to fix this problem.  I'm only providing this because I realize the realities of working on enormous projects or projects where you do not have full control over the HTML.
</div>


<p>This is the same approach as #2, but the appropriate links are changed in JavaScript instead of forcing you to fix every link manually.</p>

<p>The hack is shown below, simply call the <code>makeTabs</code> function with the selector used to create the tabs widget:</p>

<p>``` javascript
var makeTabs = function(selector) {</p>

<pre><code>$( selector )
    .find( "ul a" ).each( function() {
        var href = $( this ).attr( "href" ),
            newHref = window.location.protocol + '//' + window.location.hostname + 
                window.location.pathname + href;

        if ( href.indexOf( "#" ) == 0 ) {
            $( this ).attr( "href", newHref );
        }
    })
$( selector ).tabs();
</code></pre>

<p>};</p>

<p>makeTabs( "#tabs" );
```</p>

<p>As noted by the warning box, you should really fix this the right way.  But desperate times call for desperate measures.  You've been warned.</p>

<h3>The End</h3>

<p>Hopefully if you didn't understand how to use the <code>&lt;base&gt;</code> tag and jQuery UI's tab widget together you do now.  If you are still having issues after reading through this please let me know in the comments.</p>

<h3>Update (March 6th, 2013)</h3>

<p>Per comments from rubensa, I've removed <code>window.location.origin</code> from my JavaScript workaround since it's a WebKit only property.  He also pointed out that if you might need to explicitly include a port number in the URL if you're using it in your local development.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the body Element as a Top Level Container - Is it Safe Yet?]]></title>
    <link href="http://tjvantoll.com/2013/01/05/is-it-safe-to-use-the-body-as-a-top-level-container-yet/"/>
    <updated>2013-01-05T14:21:00-05:00</updated>
    <id>http://tjvantoll.com/2013/01/05/is-it-safe-to-use-the-body-as-a-top-level-container-yet</id>
    <content type="html"><![CDATA[<p>View source on almost any web page and you'll likely see the following:</p>

<p>``` html Common HTML Template
<html></p>

<pre><code>&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;div id="wrapper"&gt;
        &lt;!-- All the things --&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>The use of a wrapper or container <code>div</code> around the page is fairly universal.  It is commonly used to perform tasks such as centering a page's content or providing a shadow or border to frame it.  But, since the <code>body</code> element is a necessity in the markup, why can't it be styled directly instead?  Why is a wrapper <code>div</code> used?</p>

<p>Historically there have been a number of issues with using the <code>body</code> element as a top level container in old versions of Internet Explorers.  If you're supporting IE >= 8 you're good, but there are some things <a href="#now">you should be aware of</a>.</p>

<!--more-->


<h3>IE 5.5</h3>

<p>To get to the origins of the wrapper <code>div</code> let's go way back.  A pretty common practice is to center the top level container using <code>margin: 0 auto</code>, and this works fine in all browsers... back to IE 5.5.  IE 5.5 did not support <code>auto</code> margins so this approach did not work.</p>

<p>To center the top level container in IE 5.5 you had to make use of <code>text-align: center</code> as such:</p>

<p>``` css Centering the top level container in IE 5.5
body {</p>

<pre><code>text-align: center;
</code></pre>

<p>}</p>

<h1>wrapper {</h1>

<pre><code>width: 1000px;
text-align: left; /* counteract the declaration on body */
</code></pre>

<p>}
```</p>

<p><code>text-align: center</code> <em>should</em> only affect inline elements, but IE 5.5 incorrectly applied it to block elements as well.  (Note: The <code>text-align: center</code> bug was fixed in IE6 standards mode, but the behavior remained in Internet Explorer's quirks mode to this day.)</p>

<h3>IE6</h3>

<p>IE6 implemented <code>auto</code> margins, so <code>margin: 0 auto</code> was now safe to use on the <code>body</code>.  Additionally, IE6 fully supports adding a <code>width</code>, <code>padding</code>, <code>margin</code>, and <code>border</code> to the body element.  Take the following CSS:</p>

<p>``` css
body{</p>

<pre><code>width: 90%;
border: 2px solid red;
background-color: black;
color: white;
padding: 10px;
margin: 0 auto;
</code></pre>

<p>}
```</p>

<p>The layout renders the same in IE6 as it does in the latest version of Chrome (23 as of this writing).</p>

<div style="overflow: hidden;">
    <div style="float: left; width: 49%;">
        <h4>IE6</h4>
        <img title="Styling the body element in IE6" src="http://tjvantoll.com/images/posts/2013-01-05/IE6.png">
    </div>
    <div style="float: right; width: 49%;">
        <h4>Chrome</h4>
        <img title="Styling the body element in Chrome" src="http://tjvantoll.com/images/posts/2013-01-05/Chrome.png">
    </div>
</div>


<p>Believe it or not using the <code>body</code> element as a top level container is actually safe in IE6.</p>

<p><a name="zoom"></a></p>

<h3>IE7</h3>

<p>If there are no issues with IE6 why am I still writing?  IE7 introduced a feature new to Internet Explorer, zoom, and with it came a new bug.</p>

<p>When a <code>margin</code> or <code>width</code> is applied to the <code>body</code> and the user zooms, IE7 incorrectly treats the left edge of the <code>body</code> as the edge of the viewport.  This shift bumps content on the right hand side of the page outside of the screen.  The image below shows the result of a zoomed in window and styled <code>body</code> in IE7.</p>

<p><img src="http://tjvantoll.com/images/posts/2013-01-05/IE7Zoom.png" title="Zooming in IE7" style="max-height: 400px;"></p>

<p>This issue is not present using a wrapper <code>div</code>.</p>

<h3>Beyond IE7</h3>

<p>In my testing beyond IE7 there are no major issues using the <code>body</code> element as a top level container.  There are however a few things to be aware of.</p>

<p><a name="now"></a></p>

<h3>Positioning</h3>

<p>Any absolutely positioned elements will be positioned relative to the viewport rather than the newly placed <code>body</code>.  To fix this set <code>position: relative</code> on the <code>body</code> as such:</p>

<p>``` css Positioning elements relative to the body rather than the viewport
body {</p>

<pre><code>margin: 0 auto;
width: 90%;
position: relative;
</code></pre>

<p>}
```</p>

<h3>Backgrounds</h3>

<p>Backgrounds applied to the <code>body</code> will take up whole page regardless of margins.  Consider the following:</p>

<p>``` css
body {</p>

<pre><code>background: black;
margin: 0 auto;
width: 200px;
</code></pre>

<p>}
```</p>

<p>The screenshot below shows this.  The background of the entire viewport is black rather than a centered 200px block.</p>

<p><img src="http://tjvantoll.com/images/posts/2013-01-05/background-before.png" title="background on a body element" style="max-height: 300px;"></p>

<p>This can be worked around by applying a <code>background</code> on the <code>html</code> element:</p>

<p>``` css
html {</p>

<pre><code>background: white;
height: 100%;
</code></pre>

<p>}
body {</p>

<pre><code>background: black;
margin: 0 auto;
width: 200px;
min-height: 100%;
</code></pre>

<p>}
```</p>

<p>Note the <code>height</code> that was added to the <code>html</code> element and the <code>min-height</code> added to the <code>body</code>.  This ensures that the <code>background</code> applied to the <code>body</code> element will take up the entire height of the screen.</p>

<p>The rules above will now render as expected:</p>

<p><img src="http://tjvantoll.com/images/posts/2013-01-05/background-after.png" title="background on a body element with background on html element" style="max-height: 300px;"></p>

<h3>scrollHeight and scrollWidth</h3>

<p>In WebKit based browsers the <code>body</code>'s <a href="https://developer.mozilla.org/en-US/docs/DOM/element.scrollHeight">scrollHeight</a> and <a href="https://developer.mozilla.org/en-US/docs/DOM/element.scrollWidth">scrollWidth</a> properties are unaffected by declared <code>height</code> and <code>width</code> styles.  For example:</p>

<p>``` html scrollHeight and scrollWidth on the body element
<html></p>

<pre><code>&lt;head&gt;&lt;/head&gt;
&lt;body style="height: 200px; width: 200px;"&gt;
    &lt;script&gt;
        console.log(document.body.scrollHeight);
        console.log(document.body.scrollWidth);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>This will log <code>200</code> for both in all modern browsers with the exception of WebKit based ones.  WebKit will return the height and width of the viewport.</p>

<p>While you are unlikely to run into this directly, you may use a library that does.  For example, this <a href="http://bugs.jqueryui.com/ticket/8940">causes an issue</a> trying to constrain <a href="http://jqueryui.com/draggable/">jQuery UI draggables</a> within the <code>body</code>.</p>

<h3>Is it Safe to Use Yet?</h3>

<p>The <a href="#zoom">zoom issue in IE7</a> is bad, but if you're no longer supporting IE7 it's safe to drop the wrapper <code>div</code> and style the <code>body</code> directly.</p>

<p>That being said, there's no harm in leaving a wrapper <code>div</code> in place.  So if you have any doubt stick with <code>&lt;div id="wrapper"&gt;&lt;/div&gt;</code>.</p>

<p>Know of any other bugs with styling the <code>body</code> element?  Let me know in the comments.</p>
]]></content>
  </entry>
  
</feed>
