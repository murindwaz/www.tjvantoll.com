<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web Components | TJ VanToll]]></title>
  <link href="http://tjvantoll.com/blog/categories/web-components/atom.xml" rel="self"/>
  <link href="http://tjvantoll.com/"/>
  <updated>2014-09-18T13:13:40-04:00</updated>
  <id>http://tjvantoll.com/</id>
  <author>
    <name><![CDATA[TJ VanToll]]></name>
    <email><![CDATA[tj.vantoll@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Problem With Using HTML Imports For Dependency Management]]></title>
    <link href="http://tjvantoll.com/2014/08/12/the-problem-with-using-html-imports-for-dependency-management/"/>
    <updated>2014-08-12T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2014/08/12/the-problem-with-using-html-imports-for-dependency-management</id>
    <content type="html"><![CDATA[<p>HTML imports are cool. If you haven't heard of them before, you should read <a href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/">Eric Bidelman's excellent introduction to them</a>, but they're pretty self explanatory with a bit of code. For example the following is how a jQuery UI dialog works in <a href="https://github.com/tjvantoll/ui-web-components">my proof-of-concept web components port</a>:</p>

<p>``` html
<link rel="import" href="ui-dialog.html"></p>

<p><ui-dialog title="Hello World"></ui-dialog>
```</p>

<p>The cool thing here is not what you see—a <code>&lt;link&gt;</code> tag that imports a custom element—but rather, what you don't. Normally when using jQuery UI widgets, you have to worry about a number of JavaScript and CSS dependencies, such as jQuery Core, the widget factory, a CSS theme, and more. With HTML imports you don't, as the import takes care of bundling everything you need.</p>

<!--more-->


<h3>OMG Awesome! What's the problem?</h3>

<p>HTML imports transfer the dependency management burden from component consumers to component authors. This sounds good, until you think about <em>how</em> to reconcile those dependencies.</p>

<p>Suppose you want to write a component that depends on jQuery. How might you do that? Well, the easiest way is to package jquery.js within your web component, and to reference it in your HTML import with a simple <code>&lt;script&gt;</code> tag:</p>

<p>``` html</p>

<script src="jquery.js"></script>


<p>```</p>

<p>This works, and is simple, but it has a serious repercussion: jquery.js is bundled with your component. That means, with this approach, if a user imports five jQuery-dependent components, the browser will download jQuery five times. And because reducing HTTP requests is a vital web performance optimization, this is <a href="https://www.youtube.com/watch?v=H8OxKx6zKkQ">kind of a big deal</a>.</p>

<h3>What about de-duping?</h3>

<p>De-duping, besides being an awesome word to say, is a mechanism built into HTML imports to prevent multiple requests for the same resource. That is, if multiple imports reference the same URL, the browser is smart enough to only retrieve the resource once.</p>

<p>The problem is the de-duping mechanism only works on <em>exact</em> URL matches. Different domains, different protocols, different versions, and so forth are each enough to subvert the de-duping process.</p>

<p>The crux of the issue is that dependencies in HTML imports aren't strings like "jquery" and "bootstrap", they're URLs like "http://code.jquery.com/jquery-2.1.1.min.js" and "http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"—and there's no way of knowing what the consumer of the component expects.</p>

<p>What's an HTML import with external dependencies to do? <a href="http://www.polymer-project.org/resources/faq.html#loadlibs">Polymer's documentation</a> gives the following recommendation in its FAQ:</p>

<blockquote><p>"If multiple libraries want to share a dependency, they will have to agree on a system. Feature detection, or an agreed upon common location for a ‘jquery.html’ file in a CDN, etc."</p></blockquote>

<p>Getting libraries to agree on <em>anything</em> in the web world has been painfully difficult, but it's definitely worth a discussion. Let's look at each of these options in detail.</p>

<h3>Options for managing external dependencies</h3>

<p>To discuss our options, let's suppose that you want to build a hypothetical <code>&lt;formatted-time&gt;</code> custom element as an HTML import, and you want to use <a href="http://momentjs.com/">Moment.js</a> as part of your implementation.</p>

<p>Assuming that you don't package Moment.js as part of your component, and we've already seen why that's a bad idea, here are your options:</p>

<h4>Option 1: Use a CDN</h4>

<p>You could refer to Moment.js on some CDN, for instance the following <code>&lt;script&gt;</code> tag imports Moment.js from <a href="http://cdnjs.com/">cdnjs</a>:</p>

<p>```</p>

<script src="http://tjvantoll.com//cdnjs.cloudflare.com/ajax/libs/moment.js/2.7.0/moment.min.js"></script>


<p>```</p>

<p>This approach works, but it has some major disadvantages. For one, the CDN approach only prevents multiple downloads of Moment.js if everyone magically chooses to retrieve Moment.js from the exact same URL—same CDN provider, same protocol, same version, and so forth. Second, the CDN reference also prevents the usage of script concatenation tooling, which is an essential performance optimization, especially for mobile. Because of this, I don't see CDNs as a viable option for managing external dependencies.</p>

<h4>Option 2: Enforce a folder structure</h4>

<p>The next option you have is enforcing a specific directory structure on the consumer of your component. For instance, you could enforce that users have a folder structure that looks like this:</p>

<p>```
.
├── momentjs
│   └── moment.js
└── formatted-time</p>

<pre><code>└── formatted-time.html
</code></pre>

<p>```</p>

<p>With this structure in place, your formatted-time.html file can reference moment.js using <code>&lt;link rel="import" href="../momentjs/moment.js"&gt;</code>. This is the strategy Polymer itself uses, as all Polymer core elements include an import of <code>&lt;link rel="import" href="../polymer/polymer.html"&gt;</code> to get the dependencies they need.</p>

<p>This approach works well if your users manage their dependencies through a package manager such as Bower, as the package manager provides a defined structure you can rely on. But the reality is only a small fraction of the web uses Bower, and the developers that do often have build scripts in place to move files to locations that their servers and development environments require.</p>

<p>Enforcing a directory structure for dependencies can theoretically work, but it requires the community to agree on and standardize a directory structure to use, which is a tall task.</p>

<p>Worse, even agreeing on a directory structure isn't enough, as the exact file paths must match to prevent multiple downloads. If component A references <code>"../momentjs/moment.js"</code>, and component B references <code>"../momentjs/min/moment.min.js"</code>, the browser sees two different resources that need to be individually downloaded.</p>

<h4>Option 3: Feature detection</h4>

<p>The next option is feature detection, or determining whether your dependency has already been loaded, and if not, loading it yourself. For example, with the <code>&lt;formatted-time&gt;</code> element you could use the following code to load conditionally load Moment.js:</p>

<p>``` javascript</p>

<script>
    (function() {
        var script;
        if ( typeof window.moment === "undefined" ) {
            script = document.createElement( "script" );
            script.src = "path/to/formatted-time/moment.js";
            document.body.appendChild( script );
        }
    }());
</script>


<p>```</p>

<blockquote><p><strong>Update August 13th, 2014</strong>—As is, this code is not enough to prevent loading Moment.js multiple times, as two modules could request the script before it has been asynchronously fetched and parsed. To avoid multiple requests correctly you'd need to <a href="#comment-1540666406">additionally add some boolean logic</a>. Thanks <a href="https://twitter.com/webreflection">@webreflection</a>!</p></blockquote>

<p>This approach avoids the problem of loading Moment.js multiple times, but there's still a major problem: the path to use for moment.js. Because you need to do a feature check, and because <code>document.write</code>s are not permitted in HTML import files, you must load feature-checked dependencies asynchronously. And when you do that, the path of the dependency is not relative to the current HTML import file; it's relevant to the root of the application—and there's no way of knowing what that is in a distributable component. You could use a CDN path, but that's subject to the problems discussed in <strong>Option 1</strong>.</p>

<p>Doing a feature check also prevents the usage of HTML import build tools such as <a href="https://github.com/Polymer/vulcanize">Vulcanize</a>, which inlines all HTML import dependencies into a single file—a vital performance optimization for anyone using HTML imports in a production setting. In theory build tools like Vulcanize could help manage these dependencies in the future, but at the moment such a mechanism does not exist.</p>

<h4>Option 4: Don't use HTML imports for external dependencies</h4>

<p>The final option you have is to avoid using HTML imports to manage external dependencies. For the <code>&lt;formatted-time&gt;</code> example, this means not referencing moment.js in your component at all; you just assume that it's there and note that it's a requirement in your documentation—exactly like you do today.</p>

<p>Of course, this subverts the main purpose of building an HTML import—building a self-contained module—but at the moment I don't see a better option.</p>

<h3>Where to go from here?</h3>

<p>I don't have the solution, but I think we need to be having this discussion if we want to see high quality HTML imports that don't have negative performance consequences. I'd love to hear your thoughts on this in the comments.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Addendum to Why Web Components Aren't Ready for Production Yet]]></title>
    <link href="http://tjvantoll.com/2014/07/18/an-addendum-to-why-web-components-arent-ready-for-production-yet/"/>
    <updated>2014-07-18T14:14:00-04:00</updated>
    <id>http://tjvantoll.com/2014/07/18/an-addendum-to-why-web-components-arent-ready-for-production-yet</id>
    <content type="html"><![CDATA[<p>Yesterday I <a href="http://developer.telerik.com/featured/web-components-arent-ready-production-yet/">published an article on the Telerik Developer Network</a> about the state of web components. In it I argued that web components are not ready for the majority of web developers to use in production.</p>

<p>I was overwhelmed by the amount of feeback—positive and negative—that I received after the article went live. In my opinion this is one of the great things about writing on the web. Opinionated posts tend to attract feedback from smart people with vested interests in the technology being discussed. Although putting yourself out there for criticism is hard, it's also a spectacular way to learn. Here I want to summarize what I learned from writing about web components, and take a minute to respond to some of the criticism I received.</p>

<!--more-->


<h3>The Title</h3>

<blockquote class="twitter-tweet" lang="en"><p>Why Web Components Aren’t Ready for Production… Yet <a href="http://t.co/0liPap0bWx">http://t.co/0liPap0bWx</a> sensible research, dangerous title. STOP! More at <a href="https://twitter.com/forwardJS">@forwardJS</a></p>&mdash; Christian Heilmann (@codepo8) <a href="https://twitter.com/codepo8/statuses/489781679272509440">July 17, 2014</a></blockquote>


<p>Several people said that my title was far too generic and link baity. This is somewhat fair, but I think the article gives the necessary context to explain why I chose a generic title. From the article...</p>

<blockquote><p>"All of Polymer’s elements, and most (all?) of the elements listed on http://customelements.io/ and http://component.kitchen/ depend on Polymer, which depends on the platform in its entirety."</p></blockquote>

<p>Put yourselves in the shoes of a developer debating whether to use web components in your app. The first thing you're going to want to do is see an existing component, and the overwhelming majority of published components are Polymer based. Even if you don't end up using Polymer, if you use just one Polymer-based element, you are subject to the performance penalties I outline in my article.</p>

<p>Although the conclusion of the article is that web components aren't ready for production, that isn't necessarily because the technology behind them isn't ready. A large part of the problem is that there isn't enough documentation available to developers. What are the performance repercussions of each of the various web components polyfills? How do you build performant web components? This is research that needs to be done before the average developer can take web components seriously.</p>

<h3>Not all web components solutions are created equally</h3>

<p>Several people called me out for grouping all web components solutions together. Although I acknowledged that there are alternative libraries out there, I didn't do a very good job differentiating them from Polymer in terms of performance.</p>

<blockquote data-conversation="none" class="twitter-tweet" lang="en"><p><a href="https://twitter.com/tjvantoll">@tjvantoll</a> <a href="https://twitter.com/codepo8">@codepo8</a> <a href="https://twitter.com/slightlylate">@slightlylate</a> <a href="https://twitter.com/WebReflection">@WebReflection</a> X-Tag used only Custom Elements since day 1, judging them as one is *extremely* misleading.</p>&mdash; Daniel (@csuwildcat) <a href="https://twitter.com/csuwildcat/statuses/489790523201187842">July 17, 2014</a></blockquote>


<p>I knew that X-Tag used a subset of web components polyfills, and I mention that in the article, but I didn't realize they <em>only</em> use custom elements. This is exactly the sort of thing I'd love to see more information on. Why did X-Tag choose to only go with custom elements? Performance? File size?</p>

<p>I also discovered several other projects that are web components based. <a href="http://bosonic.github.io/index.html">Bosonic</a> takes a transpilation approach, and converts HTML-based web component files into JS and CSS code that works back to IE9. This is another project I'd love to hear more information about, especially their design choices.</p>

<p><img src="http://tjvantoll.com/images/posts/2014-07-18/bosonic.png"></p>

<p>I was also pointed at an <a href="http://webreflection.blogspot.co.uk/2014/07/a-w3c-custom-elements-alternative.html">alternative custom elements polyfill from Andrea Giammarchi</a>. The polyfill is less than 2K minified and gzipped, and supports an impressive range of browsers. This is another project worth experimenting with.</p>

<h3>My tone</h3>

<p>The last thing I want to discuss is my tone in the article, as that was called out by a few people.</p>

<blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/tjvantoll">@tjvantoll</a> <a href="https://twitter.com/csuwildcat">@csuwildcat</a> <a href="https://twitter.com/codepo8">@codepo8</a> <a href="https://twitter.com/WebReflection">@WebReflection</a> : OK, fine, but downer pieces like yours that don&#39;t do that work don&#39;t contribute to that.</p>&mdash; Alex Russell (@slightlylate) <a href="https://twitter.com/slightlylate/statuses/489793567007571969">July 17, 2014</a></blockquote>




<blockquote class="twitter-tweet" lang="en"><p>Why Web Components aren&#39;t ready for production yet - <a href="https://twitter.com/tjvantoll">@tjvantoll</a> - <a href="http://t.co/4EEQIHtmWe">http://t.co/4EEQIHtmWe</a> Valid points, bit too negatively brought imho</p>&mdash; Leon de Rijke (@leonderijke) <a href="https://twitter.com/leonderijke/statuses/489856563327537152">July 17, 2014</a></blockquote>


<p>I want to make it <em>very clear</em> that I am not trying to be a web component naysayer. I am excited about web components, and the article presents my honest feedback from someone that wants to move forward with them in major libraries, but ran into roadblocks. In my opinion, putting this feedback in the open starts conversations that we need to have to start seriously considering web components.</p>

<p>Per the feedback I received, and based on my own experience, the sanest place for developers to start is with custom elements, as it has a relatively sane polyfill. Or as <a href="https://twitter.com/csuwildcat">@csuwildcat</a> puts it...</p>

<blockquote data-conversation="none" class="twitter-tweet" lang="en"><p><a href="https://twitter.com/tjvantoll">@tjvantoll</a> <a href="https://twitter.com/WebReflection">@WebReflection</a> <a href="https://twitter.com/slightlylate">@slightlylate</a> <a href="https://twitter.com/codepo8">@codepo8</a> shout this: deploy UI as custom elements today, &amp; when Shadow DOM is native, hide the guts.</p>&mdash; Daniel (@csuwildcat) <a href="https://twitter.com/csuwildcat/statuses/489800753997828097">July 17, 2014</a></blockquote>


<p>Consider it shouted. This is certainly something we need more people to experiment with, myself included.</p>

<h3>Thanks</h3>

<p>Finally I want to thank everyone that contributed feedback in some fashion. Writing on the internet is a great way to learn from others, and that's certainly true in this case. With that in mind I want to encourage people that have used web components to share their experiences—especially those that have attempted to use them in production. Let's make this happen.</p>

<script async src="http://tjvantoll.com//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
</feed>
