<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: HTML5 | TJ VanToll's Blog]]></title>
  <link href="http://tjvantoll.com/blog/categories/html5/atom.xml" rel="self"/>
  <link href="http://tjvantoll.com/"/>
  <updated>2015-05-22T12:24:23-04:00</updated>
  <id>http://tjvantoll.com/</id>
  <author>
    <name><![CDATA[TJ VanToll]]></name>
    <email><![CDATA[tj.vantoll@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A reportValidity() Use Case and Polyfill]]></title>
    <link href="http://tjvantoll.com/2015/01/28/reportvalidity/"/>
    <updated>2015-01-28T00:00:00-05:00</updated>
    <id>http://tjvantoll.com/2015/01/28/reportvalidity</id>
    <content type="html"><![CDATA[<p>Last week Chrome 40 was released, and while the greater web community <a href="https://twitter.com/addyosmani/status/558051510840356864">was celebrating service workers landing</a>, a little known DOM method made its first appearance in a browser: <code>reportValidity()</code>.</p>

<p>Because I don't think many people know what <code>reportValidity()</code> does, I thought I'd write a quick article about it. Personally I think the best way to explain <code>reportValidity()</code> is with a real-world example, so let's start there.</p>

<!-- more -->


<h2><code>reportValidity()</code> use case: a registration form</h2>

<p>Suppose that you're building a registration form and you require a username:</p>

<pre class="language-markup line-numbers"><code>&lt;form&gt;
    &lt;label&gt;
        Username:
        &lt;input required&gt;
    &lt;/label&gt;
    ...
    &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>


<p>The username is required so you use a <code>required</code> attribute. But there's another common username requirement that you can't handle with an HTML attribute: uniqueness. You can't have two “bieber_fan_2003”s in your system after all.</p>

<p>So typically you use some sort of server-side check to make sure the user-provided username is available. Straightfoward. But the next part is tricky, and where <code>reportValidity()</code> comes into play. If you determine that the username is not available, how do you display that error to the user using the HTML5 form validation mechanisms?</p>

<p>It <em>seems</em> like this task should be easy, and it is—at least it only requires two lines of code—but it can be unintuitive to say the least. The first thing you need to do is mark the <code>&lt;input&gt;</code> as invalid, which you can do by calling <code>setCustomValidity()</code> on it with the error message you want to use:</p>

<pre class="language-javascript"><code>document.querySelector( "input" )
    .setCustomValidity( "This username is not available" );</code></pre>


<p>This tells the browser that the text in the <code>&lt;input&gt;</code> is invalid (<code>setCustomValidity()</code> considers an empty string valid, and non-empty strings invalid), but it does not <em>report</em> the error to the user—aka the user doesn't see any bubbles. That is what <code>reportValidity()</code> does:</p>

<pre class="language-javascript"><code>document.querySelector( "form" ).reportValidity();</code></pre>


<p><code>reportValidity()</code> displays the form's first error to the user using the browser's native validation bubbles. Here's what it looks like:</p>

<p><img src="http://tjvantoll.com/images/posts/2015-01-28/error-message.png" alt=""></p>

<h2>Report errors without <code>reportValidity()</code></h2>

<p>You may be wondering, if this is such a common use case, how did you report errors before <code>reportValidity()</code>? The completely unintuitive way to do that is by...  wait for it.... clicking the <code>&lt;form&gt;</code>'s submit button in JavaScript:</p>

<pre class="language-javascript"><code>document.querySelector( "button" ).submit();</code></pre>


<p>OF COURSE, right? Here's a <a href="http://jsfiddle.net/tj_vantoll/fdofmt7o/">live example</a> that proves this technique works, in case you don't believe me.</p>

<p>Basically, clicking the submit button mimics an actual user submission, which triggers the HTML form validation algorithm, which reports the first error to the user. The thing is, if you wanted to report errors to the user you'd never think to use JavaScript to click the submit button, you'd look for a method named something like, oh I don't know, <code>reportValidity()</code>.</p>

<h2>Polyfill</h2>

<p>Because <code>reportValidity()</code> and “clicking” a submit button in JavaScript are essentially equivalent actions, you can write a polyfill that takes advantage of this similarity. The following code does just that. You can include it to gain the ability to use <code>reportValidity()</code> in Firefox and IE 10+ (the first version of IE with an HTML5 form validation implementation):</p>

<pre class="language-javascript line-numbers"><code>if ( !HTMLFormElement.prototype.reportValidity ) {
    HTMLFormElement.prototype.reportValidity = function() {
        var submitButtons = this.querySelectorAll( "button, input[type=submit]" );
        for ( var i = 0; i < submitButtons.length; i++ ) {
            // Filter out &lt;button type="button"&gt;, as querySelectorAll can't
            // handle :not filtering
            if ( submitButtons[ i ].type === "submit" ) {
                submitButtons[ i ].click();
                return;
            }
        }
    }
}</code></pre>


<blockquote><p>This also adds support to Safari, but Safari does not have a native error reporting mechanism (i.e. bubbles), so you have to add your own. I went through some strategies to do so at a talk I gave last year. Here are <a href="http://tjvantoll.com/speaking/slides/Constraint-Validation/Chicago/">the slides</a> and here's the <a href="https://www.youtube.com/watch?v=8qvjhMr6UGM&amp;list=PL-0yjdC10QYpmXI3l-PGK1od4kTWOjm_A&amp;index=12">video</a> if you're interested.</p></blockquote>

<p>This polyfill relies on all forms having a submit button because having one is a <a href="http://www.smashingmagazine.com/2014/05/21/mobile-accessibility-why-care-what-can-you-do/">best practice</a>, but you could easily alter the script to insert a hidden submit button into the DOM if you really wanted to.</p>

<h2>Who cares?</h2>

<p>Ok, I'll admit that a single DOM method being shipped isn't life altering, but it's a small thing that makes HTML5 form validation a little easier to implement. I've been <a href="http://tjvantoll.com/speaking/slides/Constraint-Validation/Atlanta/">advocating the usage of HTML form validation</a> for a long time now, but <a href="https://www.youtube.com/watch?v=8qvjhMr6UGM&amp;list=PL-0yjdC10QYpmXI3l-PGK1od4kTWOjm_A&amp;index=12">very few people actually use it in production</a>. I'm hoping that <code>reportValidity()</code> is a sign that browsers vendors care and are willing to put some effort into making HTML5 form validation easier to use.</p>

<p>Firefox <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1088761">has a ticket for <code>reportValidity()</code></a>, but I have no clue if IE has this method on their roadmap. WebKit can't consider <code>reportValidity()</code> until they actually have a means of reporting errors—i.e. bubbles. WebKit has a <a href="https://bugs.webkit.org/show_bug.cgi?id=28649">ticket to add bubbles</a>, but it has been inactive since 2010.</p>

<p>Oh, and browser vendors, if you're listening, I have two other things on my form validation wish list that still have zero implementations:</p>

<ul>
<li>1) There's a new <code>invalid</code> event on <code>&lt;form&gt;</code> elements (see <a href="http://www.w3.org/html/wg/drafts/html/master/forms.html#form-submission-algorithm">step 4 on this form submission algorithm</a>) that makes <a href="http://tjvantoll.com/speaking/slides/Constraint-Validation/Chicago/#/28">aggregating error messages</a> a lot easier.</li>
<li>2) There's a <a href="http://dev.w3.org/csswg/selectors-4/#user-pseudos"><code>:user-error</code> pseudo-class</a> in the CSS Selectors 4 spec that's <a href="http://tjvantoll.com/speaking/slides/Constraint-Validation/Chicago/#/33">far more useful than <code>:invalid</code></a>.</li>
</ul>


<p>Let's make it happen!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating a jQuery UI Dialog with a Submit Button]]></title>
    <link href="http://tjvantoll.com/2013/07/10/creating-a-jquery-ui-dialog-with-a-submit-button/"/>
    <updated>2013-07-10T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2013/07/10/creating-a-jquery-ui-dialog-with-a-submit-button</id>
    <content type="html"><![CDATA[<p>Say you have the following submittable <code>&lt;form&gt;</code>:</p>

<p>``` html
<form id="myForm" action="http://google.com"></p>

<pre><code>&lt;label for="search"&gt;Search For:&lt;/label&gt;
&lt;input type="text" id="search" name="q"&gt;
&lt;button type="submit"&gt;Find&lt;/button&gt;
</code></pre>

<p></form>
```</p>

<p>And you want to show the form in a jQuery UI dialog. You can do that with the code below:</p>

<p>``` javascript Turning a form into a dialog
$( "form" ).dialog({</p>

<pre><code>open: function() {
    // On open, hide the original submit button
    $( this ).find( "[type=submit]" ).hide();
},
buttons: [
    {
        text: "Find",
        click: $.noop,
        type: "submit"
    },
    {
        text: "Close",
        click: function() {
            $( this ).dialog( "close" );
        }
    }
]
</code></pre>

<p>});
```</p>

<p>Which looks like this:</p>

<p><img src="http://tjvantoll.com/images/posts/2013-07-10/form-dialog.png" alt="Display of the form within a jQuery UI dialog"></p>

<h3>The Problem</h3>

<p>There's one problem with this - the "Find" button doesn't work. Because of the generated structure of a jQuery UI dialog, the buttons are not within the <code>&lt;form&gt;</code> itself. Therefore, the buttons are not associated with the <code>&lt;form&gt;</code>. You can see the structure below:</p>

<!-- more -->


<p><img src="http://tjvantoll.com/images/posts/2013-07-10/markup.png" alt="Markup of a UI dialog showing the the buttons are not children of the content."></p>

<p>Note that the <code>&lt;button type="submit"&gt;</code> is not within the <code>&lt;form&gt;</code>.</p>

<h3>Solution</h3>

<p>There are a few ways we can work around this. One is avoid the <a href="http://api.jqueryui.com/dialog/#option-buttons">buttons option</a> and leave the original submit button in place. This works, but you lose the formatted display.</p>

<h3>Explicit Click Handler</h3>

<p>Another solution is to add a <code>click</code> handler to the button that submits the form:</p>

<p>``` js Using a Click Handler to Submit the Form
var form = $( "form" ).dialog({</p>

<pre><code>...
buttons: [
    {
        text: "Find",
        click: function() {
            form.submit();
        }
    }
    ...
]
</code></pre>

<p>});
```</p>

<p>This works, but you lose the browsers <a href="/2013/01/01/enter-should-submit-forms-stop-messing-with-that/">browser's default enter key handling</a>. Therefore it has to be replicated as well:</p>

<p>``` javascript Adding Enter Key Handling
var form = $( "form" ).dialog({ ... });
form.on( "keypress", "input[type=text]", function( event ) {</p>

<pre><code>if ( event.keyCode == 13 ) {
    form.submit();
}
</code></pre>

<p>});
```</p>

<h4>Form Attribute</h4>

<p>An elegant solution to this problem is to use HTML5's new <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-form">form attribute</a>. The attribute allows you to associate a <code>&lt;form&gt;</code> with a <code>&lt;button&gt;</code>, even if the <code>&lt;button&gt;</code> is not a descendant of the <code>&lt;form&gt;</code>. It's even smart enough to keep the <a href="/2013/01/01/enter-should-submit-forms-stop-messing-with-that/">browser's default enter key handling</a> in place.</p>

<p>For example here's the example <code>&lt;form&gt;</code> with a sibling (rather than child) submit button:</p>

<p>``` html
<form id="myForm" action="http://google.com"></p>

<pre><code>&lt;label for="search"&gt;Search For:&lt;/label&gt;
&lt;input type="text" id="search" name="q"&gt;
</code></pre>

<p></form>
<button type="submit" form="myForm">Find</button>
```</p>

<p>The <code>&lt;button&gt;</code> is outside of the <code>&lt;form&gt;</code>, but because its <code>form</code> attribute is equal to the <code>&lt;form&gt;</code>'s <code>id</code>, the <code>&lt;button&gt;</code> will submit the <code>&lt;form&gt;</code> regardless.</p>

<h4>Using the Form Attribute on a Dialog</h4>

<p>To add this attribute to the dialog version, we'll pass <code>form: "myForm"</code> into the <code>buttons</code> option for the Find button:</p>

<p>``` html Turning a form into a dialog
<form id="myForm" action="http://google.com"></p>

<pre><code>&lt;label for="search"&gt;Search For:&lt;/label&gt;
&lt;input type="text" id="search" name="q"&gt;
&lt;button type="submit"&gt;Find&lt;/button&gt;
</code></pre>

<p></form></p>

<script>
    $( "form" ).dialog({
        open: function() {
            // On open, hide the original submit button
            $( this ).find( "[type=submit]" ).hide();
        },
        buttons: [
            {
                text: "Find",
                click: $.noop,
                type: "submit",
                form: "myForm" // <-- Make the association
            },
            {
                text: "Close",
                click: function() {
                    $( this ).dialog( "close" );
                }
            }
        ]
    });
</script>


<p>```</p>

<p><a href="/demos/2013-07-10/form.html">Live Example</a></p>

<h3>Support</h3>

<p>The <code>form</code> attribute is implemented in Firefox, Chrome, Safari 5.1+, and Opera, HOWEVER, IE (as of version 10) still does not support the attribute.</p>

<p>Because the form attribute is so handy here, I wrote a polyfill that adds support in browsers that don't support it natively: <a href="https://gist.github.com/tjvantoll/5911571">https://gist.github.com/tjvantoll/5911571</a>. The source is below:</p>

<p>``` javascript
/<em>*
 * The form attribute can be used to associate a submit button with a form, even
 * if the button is not a child of the <form> itself.
 *
 * This polyfill uses a support check taken from Modernizr and polyfills the
 * functionality using jQuery.
 </em>/
(function() {</p>

<pre><code>// Via Modernizr
function formAttributeSupport() {
    var form = document.createElement( "form" ),
        input = document.createElement( "input" ),
        div = document.createElement( "div" ),
        id = "formtest"+ ( new Date().getTime() ),
        attr,
        bool = false;

        form.id = id;

    // IE6/7 confuses the form idl attribute and the form content attribute
    if ( document.createAttribute ) {
        attr = document.createAttribute("form");
        attr.nodeValue = id;
        input.setAttributeNode(attr);
        div.appendChild(form);
        div.appendChild(input);

        document.documentElement.appendChild(div);

        bool = form.elements.length === 1 &amp;&amp; input.form == form;

        div.parentNode.removeChild(div);
    }

    return bool;
};

if ( !formAttributeSupport() ) {
    $( document )
        .on( "click", "[type=submit][form]", function( event ) {
            event.preventDefault();
            var formId = $( this ).attr( "form" ),
            $form = $( "#" + formId ).submit();
        })
        .on( "keypress", "form input", function( event ) {
            var $form;
            if ( event.keyCode == 13 ) {
                $form = $( this ).parents( "form" );
                if ( $form.find( "[type=submit]" ).length == 0 &amp;&amp;
                    $( "[type=submit][form=" + $( this ).attr( "form" ) + "]" ).length &gt; 0 ) {
                    $form.submit();
                }
            }
        });
}
</code></pre>

<p>}());
```</p>

<p>This can be included anywhere on the page after jQuery is included.</p>

<p>Note that this polyfill only attempts to add support for the <code>form</code> attribute on submit buttons. The <code>form</code> attribute can also be applied to other form elements such as <code>&lt;input&gt;</code>s, <code>&lt;select&gt;</code>s, and <code>&lt;textarea&gt;</code>s, but that is beyond the scope of this script.</p>

<p>If you encounter any issues with this polyfill let me know in the comments.</p>

<h3>Conclusion</h3>

<p>If you need a dialog with a submit button the easiest solution is to add a <code>click</code> handler that manually submits the form. While this is not ideal, it'll work everywhere with no extra effort. Just make sure that you add Enter key handling to text inputs within the <code>&lt;form&gt;</code>.</p>

<p>Long term the <code>form</code> attribute is the solution to this problem. You can try it today as long as you're aware that you need to polyfill for IE support.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML 5 hidden Attribute Browser Support]]></title>
    <link href="http://tjvantoll.com/2013/01/09/html5-hidden-attribute-browser-support/"/>
    <updated>2013-01-09T21:27:00-05:00</updated>
    <id>http://tjvantoll.com/2013/01/09/html5-hidden-attribute-browser-support</id>
    <content type="html"><![CDATA[<p>I had trouble finding this from a Google search, so I thought I'd list the browser support for the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#the-hidden-attribute">HTML5 hidden attribute</a> here.</p>

<ul>
<li>IE 11+</li>
<li>Chrome 6+</li>
<li>Firefox 4+</li>
<li>Safari 5.1+</li>
<li>Opera 11+</li>
<li>iOS 5+</li>
<li>Android Browser 4+</li>
</ul>


<p>For any unsupported browser you can easily add support by just including the following CSS:</p>

<p><code>css Polyfiling the hidden attribute.
[hidden] { display: none; }
</code></p>

<p>This will work back to IE6, which doesn't support the <a href="https://developer.mozilla.org/en-US/docs/CSS/Attribute_selectors">attribute selector</a>.</p>

<h3 id="updates">Updates</h3>


<ul>
<li>November 13th, 2013: Added that IE11 now supports the <code>hidden</code> attribute per comment from Michał Gołębiowski.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maxlength Constraint Validation Oddities in Major Browsers]]></title>
    <link href="http://tjvantoll.com/2012/10/17/maxlength-constraint-validation-oddities/"/>
    <updated>2012-10-17T12:48:00-04:00</updated>
    <id>http://tjvantoll.com/2012/10/17/maxlength-constraint-validation-oddities</id>
    <content type="html"><![CDATA[<p>The <code>maxlength</code> attribute has been around in browsers for a long time.  When provided, all browsers prevent the user entering a value that exceeds the <code>maxlength</code>.</p>

<p>For example you cannot type more than 2 characters in the textbox below:</p>

<p><input type="text" maxlength="2"></p>

<h3>Constraint Validation</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/HTML/HTML5/Constraint_validation_">Constraint validation</a> is an HTML5 spec that provides native client side form validation in the browser.  As part of its <a href="https://developer.mozilla.org/en-US/docs/HTML/Forms_in_HTML#Constraint_Validation_API">API</a>, all <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> elements have a <code>validity.tooLong</code> property that is <code>true</code> when the length of the <code>value</code> exceeds the <code>maxlength</code>.</p>

<p>But if the browser prevents this, then why does the property exist?</p>

<!--more-->


<h3>Prefilled value Attribute</h3>

<p>Assume that you're populating the <code>value</code> of form elements from a database and you end up with something like this:</p>

<p><code>&lt;input type="text" maxlength="1" value="ABC"&gt;</code></p>

<p>How will the browser handle this?</p>

<p>All browsers will prevent entry of additional characters, but they do not trim excess characters already present.  Additionally, all browsers will allow a form containing the above input to submit.  <em>Note: Opera is the only browser to set the <code>validity.tooLong</code> property to <code>true</code> in this situation.  Despite this, it does not prevent form submission.</em></p>

<p>Why is submission not prevented?  The key is in the <a href="http://www.whatwg.org/specs/web-apps/current-work/#concept-input-value-dirty-flag">specification</a>:</p>

<blockquote><p>Constraint validation: If an element has a maximum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), and the code-unit length of the element's value is greater than the element's maximum allowed value length, then the element is suffering from being too long.</p></blockquote>

<p>The <a href="http://www.whatwg.org/specs/web-apps/current-work/#concept-input-value-dirty-flag">dirty flag</a> essentially means that the user has changed the value of an element.  Therefore, in order to be <code>tooLong</code>, the element must have been edited.</p>

<h3>Actually Triggering tooLong</h3>

<p>So let's take another approach.  What happens if you have the same input:</p>

<p><code>&lt;input type="text" maxlength="1" value="ABC"&gt;</code></p>

<p>...remove one character, then submit?  You can try it for yourself below:</p>

<p><div class="code_example"><h6>Triggering tooLong Errors<a href="/demos/2012-10-17/tooLong.html" target="_blank">Open in New Window</a></h6><iframe style="width: 100%; height: 130px;" frameborder="0" src="/demos/2012-10-17/tooLong.html"></iframe></div></p>

<p>Upon edit IE10 and Chrome will set the <code>validity.tooLong</code> property to <code>true</code> and prevent form submission.  If the user attempts to submit a form after removing the "C" they will see the following in those browsers:</p>

<p><img src="/images/posts/2012-10-17/Chrome.png" title="Chrome" alt="Chrome" />
<img src="/images/posts/2012-10-17/IE10.png" title="IE10" alt="IE10" /></p>

<p>Firefox, Safari, and Opera incorrectly handle this situation and allow the form to be submitted anyways.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using jQuery UI's Slider to Polyfill HTML5's input[type=range]]]></title>
    <link href="http://tjvantoll.com/2012/09/14/using-jquery-ui-slider-to-polyfill-html5-input-type-range/"/>
    <updated>2012-09-14T21:25:00-04:00</updated>
    <id>http://tjvantoll.com/2012/09/14/using-jquery-ui-slider-to-polyfill-html5-input-type-range</id>
    <content type="html"><![CDATA[<p><a href="http://jqueryui.com/demos/slider">jQuery UI's slider plugin</a> looks and behaves much like the browser's native <code>input[type=range]</code> control; therefore it makes an excellent choice for <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfilling</a> the native behavior.</p>

<h3>How to do it</h3>

<p>The main issue is that the slider must be built on a block level node, not an <code>&lt;input&gt;</code>.  Therefore you must create another container node (in this case a <code>&lt;div&gt;</code>) to create the slider from then hide the original <code>&lt;input&gt;</code>.</p>

<p>Here's the script that I used.</p>

<!--more-->


<p>``` javascript Polyfill input[type=range] with jQuery UI's Slider
$(function() {</p>

<pre><code>//Determine whether the browser natively supports input[type=range].
//If you're using Modernizr this is equivalent to Modernizr.inputtypes.range
var input = document.createElement('input');
input.setAttribute('type', 'range');
var rangeSupport = input.type != 'text';

if (!rangeSupport) {
    var $input, $slider;

    $('input[type=range]').each(function(index, input) {
        $input = $(input);

        //Create a new div, turn it into a slider, and set its attributes based on
        //the attributes of the input.  If the input doesn't possess those attributes
        //use jQuery UI's defaults.
        $slider = $('&lt;div /&gt;').slider({
            min: parseInt($input.attr('min'), 10) || 0,
            max: parseInt($input.attr('max'), 10) || 100,
            value: parseInt($input.attr('value'), 10) || 0,
            step: parseInt($input.attr('step'), 10) || 1,
            slide: function(event, ui) {
                //Keep the value of the input[type=range] in sync with the slider.
                $(this).prev('input').val(ui.value);
            }
        });

        //Append the slider after the input and hide the input.  The user will only
        //interact with the slider.        
        $input.after($slider).hide();
    });
}
</code></pre>

<p>});
```</p>

<h3>Future</h3>

<p>This approach handles the most common use cases but it isn't perfect.  For example, if you want to disable the <code>&lt;input type="range"&gt;</code> you'll have to disable the slider as well.</p>

<p>There is a <a href="http://bugs.jqueryui.com/ticket/5800">feature request to add support for this natively in the slider plugin</a> itself, but it's been sitting inactive for quite some time now.  Hopefully over time <code>input[type=range]</code> support will become ubiquitous enough that we can drop these workarounds.</p>
]]></content>
  </entry>
  
</feed>
