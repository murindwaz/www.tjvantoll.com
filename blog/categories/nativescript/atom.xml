<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: NativeScript | TJ VanToll's Blog]]></title>
  <link href="http://tjvantoll.com/blog/categories/nativescript/atom.xml" rel="self"/>
  <link href="http://tjvantoll.com/"/>
  <updated>2015-07-04T16:51:57-04:00</updated>
  <id>http://tjvantoll.com/</id>
  <author>
    <name><![CDATA[TJ VanToll]]></name>
    <email><![CDATA[tj.vantoll@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NativeScript Quick Tip: Showing and Hiding Elements]]></title>
    <link href="http://tjvantoll.com/2015/06/05/nativescript-showing-and-hiding-elements/"/>
    <updated>2015-06-05T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2015/06/05/nativescript-showing-and-hiding-elements</id>
    <content type="html"><![CDATA[<p>NativeScript supports the <code>"collapsed"</code> and <code>"visible"</code> states of the CSS <code>visibility</code> property. This means you can hide an element by setting its <code>"visibility"</code> property to <code>"collapsed"</code> in CSS. For example you can use the following CSS to hide all buttons.</p>

<pre class="language-css"><code>button {
    visibility: collapsed;
}</code></pre>


<blockquote><p><strong>Warning</strong>: Currently NativeScript is inconsistent with the CSS spec, as the CSS spec defines <code>visibility: collapse</code>, and NativeScript uses <code>visiblity: collapsed</code>. I have <a href="https://github.com/NativeScript/NativeScript/issues/285">an issue open</a> to resolve this discrepancy.</p></blockquote>

<!-- more -->


<p>Hiding an element in CSS works, but if you need to hide an element you almost certainly need to show it at some point. For this, NativeScript exposes a <code>visibility</code> <em>attribute</em>, which is just a light wrapper around the CSS property. For instance you could also use the following syntax to hide a button:</p>

<pre class="language-markup"><code>&lt;Button text="I'm hidden" visibility="collapsed" /&gt;</code></pre>


<p>This is handy because having an attribute lets you to use <a href="http://docs.nativescript.org/bindings#using-expressions-for-bindings">data-binding expressions</a> to control the value of the attribute, which is the technique I almost always use to control visibility. To give a concrete example, in the code below I use a flag in my data model, <code>"showDetails"</code>, to determine the visibility of a <code>&lt;Label&gt;</code>.</p>

<pre class="language-markup line-numbers"><code>&lt;Page loaded="loaded"&gt;
    &lt;StackLayout&gt;
        &lt;Button text="{{ showDetails ? 'Hide' : 'Show' }}" tap="toggle" /&gt;
        &lt;Label text="Lorem ipsum..." visibility="{{ showDetails ? 'visible' : 'collapsed' }}" /&gt;
    &lt;/StackLayout&gt;
&lt;/Page&gt;</code></pre>




<pre class="language-javascript line-numbers"><code>var observable = require("data/observable");
var pageData = new observable.Observable();

exports.loaded = function(args) {
    pageData.set("showDetails", true);
    args.object.bindingContext = pageData;
}

exports.toggle = function() {
    pageData.set("showDetails", !pageData.get("showDetails"));
}</code></pre>


<p>The key here is the ternary used as part of the <code>&lt;Label&gt;</code>'s <code>visibility</code> attribute: <code>{{ showDetails ? 'visible' : 'collapsed' }}</code>. When the data model's <code>"showDetails"</code> property is true NativeScript shows the label, and when the property is false NativeScript hides the label.</p>

<p>That's all there is to it. If you have any other techniques you use to show/hide elements let me know in the comments. If you have suggestions for a cleaner API feel free to <a href="https://github.com/NativeScript/NativeScript/issues/new">suggest it on GitHub</a>, or better yet, <a href="https://www.nativescript.org/contribute">send a PR</a> :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linting JavaScript in NativeScript Apps]]></title>
    <link href="http://tjvantoll.com/2015/05/22/linting-javascript-in-nativescript-apps/"/>
    <updated>2015-05-22T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2015/05/22/linting-javascript-in-nativescript-apps</id>
    <content type="html"><![CDATA[<p>One of the great things about <a href="https://www.nativescript.org/">NativeScript</a> is you can use the JavaScript tools you already know to help build your native iOS and Android apps. In my case I recently added two tools I was already familiar with—<a href="http://jshint.com/">JSHint</a> and <a href="http://jscs.info/">JSCS</a>—to my NativeScript apps to automate <a href="http://en.wikipedia.org/wiki/Lint_%28software%29">linting</a>. In this article I'll show you how to do it too.</p>

<!-- more -->


<h2>Setting up Gulp</h2>

<p>There are a number of tools you can use to automate tasks in NativeScript apps—including <a href="http://gulpjs.com/">Gulp</a>, <a href="http://gruntjs.com/">Grunt</a>, and even <a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/">npm</a>—but I'm a fan of Gulp so that's what I'll be using in this article. First, if you don't have Gulp installed globally you'll need to grab it from npm:</p>

<pre class="language-shell"><code>npm install -g gulp</code></pre>


<p>Next, to start using Gulp in your NativeScript projects you need to make sure each project has a <code>package.json</code> file in its root:</p>

<pre class="language-shell"><code>.
├── app
│   └── ...
├── package.json ────────────── here
└── platforms
    └── ...</code></pre>


<p>If your project doesn't already have a <code>package.json</code> file, run <a href="https://docs.npmjs.com/cli/init"><code>npm init</code></a> in the project's root and npm will help you build one.</p>

<p>After that, install Gulp locally along with its <a href="https://www.npmjs.com/package/gulp-jshint">JSHint</a> and <a href="https://www.npmjs.com/package/gulp-jscs">JSCS</a> packages:</p>

<pre class="language-shell"><code>npm install gulp gulp-jshint gulp-jscs --save-dev</code></pre>


<p>The <code>--save-dev</code> flag tells npm to remember these dependencies in your newly created <code>package.json</code> file. If you open your project's <code>package.json</code> you should now see a <code>"devDependencies"</code> key at the bottom that looks something like this:</p>

<pre class="language-javascript"><code>{
  ...
  "devDependencies": {
    "gulp": "^3.8.11",
    "gulp-jscs": "^1.6.0",
    "gulp-jshint": "^1.10.0"
  }
}</code></pre>


<p>With the installation out the way, now it's time to write the code that uses these tools.</p>

<h2>Writing the task</h2>

<p>To write a Gulp task that runs JSHint and JSCS you'll need to create a <code>gulpfile.js</code> file in your project's root:</p>

<pre class="language-shell"><code>.
├── app
│   └── ...
├── gulpfile.js ────────────── here
├── package.json
└── platforms
    └── ...</code></pre>


<p>Paste the following code into your newly created <code>gulpfile.js</code>:</p>

<pre class="language-javascript line-numbers"><code>var gulp = require("gulp");
var jscs = require("gulp-jscs");
var jshint = require("gulp-jshint");

var filesToLint = [
    "app/**/*.js",

    // Exclude node modules from linting
    "!app/node_modules/**/*.js",

    // Exclude NativeScript modules from linting
    "!app/tns_modules/**/*.js"
];

gulp.task("jscs", function() {
    gulp.src(filesToLint)
        .pipe(jscs());
});

gulp.task("jshint", function() {
    return gulp.src(filesToLint)
        .pipe(jshint())
        .pipe(jshint.reporter());
});

gulp.task("lint", ["jshint", "jscs"]);</code></pre>


<p>This code defines three Gulp tasks: <code>jscs</code>, <code>jshint</code>, and <code>lint</code>. As you might expect, <code>gulp jscs</code> runs JSCS, <code>gulp jshint</code> runs JSHint, and <code>gulp lint</code> runs both.</p>

<p>The <code>filesToLint</code> array specifies which files the linters should hit. By default this is set to lint all JavaScript files in the <code>app</code> directory—excluding any npm modules you have in the <code>node_modules</code> folder, and any NativeScript modules in <code>tns_modules</code> folder—but you may wish to customize this depending on how you've structured your app.</p>

<p>With the <code>gulpfile.js</code> file in place the last thing you need to do is add a few configuration files.</p>

<h2>Configuring JSHint and JSCS</h2>

<p>JSHint and JSCS each have comprehensive sets of options for specifying exactly how they should lint your code. To specify these options, head back to the root of your project and create two files: <code>.jshintrc</code> and <code>.jscsrc</code>:</p>

<pre class="language-shell"><code>.
├── app
│   └── ...
├── gulpfile.js
├── package.json
├── platforms
│   └── ...
├── .jshintrc ────────────── here
└── .jscsrc ────────────── here</code></pre>


<p>The contents of these configuration files will depend on your personal coding preferences. I'll share my preferences if you'd like to use them as a starting point, and you can look over <a href="http://jshint.com/docs/options/">JSHint's option docs</a> and <a href="http://jscs.info/rules.html">JSCS's option docs</a> to configure them to your liking.</p>

<p>Here's my <code>.jshintrc</code>:</p>

<pre class="language-javascript"><code>{
  "boss": true,
  "curly": true,
  "esnext": true,
  "eqeqeq": true,
  "eqnull": true,
  "expr": true,
  "immed": true,
  "noarg": true,
  "quotmark": "double",
  "smarttabs": true,
  "trailing": true,
  "unused": true
}</code></pre>


<p>And here's my <code>.jscsrc</code>:</p>

<pre class="language-javascript"><code>{
  "disallowMixedSpacesAndTabs": true,
  "disallowMultipleLineBreaks": true,
  "disallowMultipleSpaces": true,
  "disallowMultipleVarDecl": true,
  "disallowNamedUnassignedFunctions": true,
  "disallowNewlineBeforeBlockStatements": true,
  "disallowSpacesInCallExpression": true,
  "disallowSpacesInFunctionDeclaration": {
    "beforeOpeningRoundBrace": true
  },
  "disallowTrailingWhitespace": true,
  "esnext": true,
  "requireCommaBeforeLineBreak": true,
  "requireCurlyBraces": ["if", "else", "for", "while", "try", "catch"],
  "requireSemicolons": true,
  "requireSpaceBetweenArguments": true,
  "requireSpacesInConditionalExpression": true,
  "requireSpacesInForStatement": true,
  "requireSpacesInsideObjectBrackets": "all",
  "validateIndentation": "\t",
  "validateQuoteMarks": "\""
}</code></pre>


<p>After you have these files in place head back to your terminal and run <code>gulp lint</code>. If all went well you should see something like this:</p>

<pre class="language-shell"><code>$ gulp lint
[12:06:49] Using gulpfile /path/to/my-project/gulpfile.js
[12:06:49] Starting 'jshint'...
[12:06:49] Starting 'jscs'...
[12:06:49] Finished 'jscs' after 84 ms
[12:06:49] Finished 'jshint' after 305 ms
[12:06:49] Starting 'lint'...
[12:06:49] Finished 'lint' after 13 μs</code></pre>


<p>If you head back into your app and create a problem, such as changing <code>var</code> to <code>vax</code>, <code>gulp lint</code> should now point out the error:</p>

<pre class="language-shell"><code>$ gulp lint
[12:09:24] Using gulpfile /path/to/my-project/gulpfile.js
[12:09:24] Starting 'jshint'...
[12:09:24] Starting 'jscs'...
[12:09:24] Finished 'jscs' after 70 ms
[12:09:24] Finished 'jshint' after 255 ms
[12:09:24] Starting 'lint'...
[12:09:24] Finished 'lint' after 6.09 μs

events.js:72
        throw er; // Unhandled 'error' event
              ^
Error: Unexpected identifier at my-file.js :
     2 |
     3 |exports.loaded = function(args) {
     4 | vax page = args.object;
--------------^
     5 | page.bindingContext = viewModel;
     6 |};</code></pre>


<h2>Wrapping up</h2>

<p>That's it! If you have any other questions about this setup let me know in the comments. If you're looking for an example of this setup in a real app, check out JustMeme, which is <a href="https://github.com/NativeScript/sample-JustMeme">available on GitHub</a> as well as the <a href="https://itunes.apple.com/us/app/justmeme/id989340374?mt=8">iOS app store</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NativeScript Quick Tip: Managing iOS Navigation Bars]]></title>
    <link href="http://tjvantoll.com/2015/03/19/nativescript-ios-navigation-bars/"/>
    <updated>2015-03-19T00:00:00-04:00</updated>
    <id>http://tjvantoll.com/2015/03/19/nativescript-ios-navigation-bars</id>
    <content type="html"><![CDATA[<p>I've gotten a whole lot of questions about adding navigation bars to NativeScript iOS apps, so I thought I'd write a quick post about it.</p>

<!-- more -->


<h2>Showing the navigation bar with a title</h2>

<p>Let's say you have the following simple NativeScript app:</p>

<pre class="language-markup line-numbers"><code>&lt;!-- main-page.xml --&gt;
&lt;Page loaded="pageLoaded"&gt;&lt;/Page&gt;</code></pre>




<pre class="language-javascript line-numbers"><code>// main-page.js
function pageLoaded(args) {
    var page = args.object;
}</code></pre>


<p>By default this app does not show a navigation bar, because that's the default iOS behavior as well. Here's how you can alter your JavaScript to show the navigation bar on iOS with a title:</p>

<pre class="language-javascript line-numbers"><code>// main-page.js
var frameModule = require("ui/frame");

exports.pageLoaded = function(args) {
    var page = args.object;

    // Make sure we're on iOS before making iOS-specific changes
    if (page.ios) {

        // Tell the frame module that the navigation bar should always display
        frameModule.topmost().ios.navBarVisibility = "always";

        // Change the UIViewController's title property
        page.ios.title = "My Awesome App";

        // Get access to the native iOS UINavigationController
        var controller = frameModule.topmost().ios.controller;

        // Call the UINavigationController's setNavigationBarHidden method
        controller.navigationBarHidden = false;
    }
};</code></pre>


<p>Here's what this looks like:</p>

<p><img src="http://tjvantoll.com/images/posts/2015-03-19/ios-nav-bar.png" class="plain" alt=""></p>

<p>All that you're doing here is invoking iOS APIs using the NativeScript runtime. <code>page.ios.title</code> sets the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instp/UIViewController/title"><code>UIViewController</code>'s <code>title</code> property</a>; <code>controller.navigationBarHidden</code> calls the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationController_Class/#//apple_ref/occ/instm/UINavigationController/setNavigationBarHidden:animated:"><code>UINavigationController</code>'s <code>setNavigationBarHidden</code> method</a>. That's it.</p>

<p>This means that in NativeScript you're not limited to what NativeScript provides; if an API exists in iOS or Android you can just call it. Let's look at one more example.</p>

<h2>Changing the navigation bar's color</h2>

<p>Let's say you want to change your navigation bar's background color. Here's how you make the navigation bar red:</p>

<pre class="language-javascript line-numbers"><code>// main-page.js
var frameModule = require("ui/frame");

exports.pageLoaded = function(args) {
    var page = args.object;

    // Make sure we're on iOS before making iOS-specific changes
    if (page.ios) {

        // Tell the frame module that the navigation bar should always display
        frameModule.topmost().ios.navBarVisibility = "always";

        // Change the UIViewController's title property
        page.ios.title = "My Awesome App";

        // Get access to the native iOS UINavigationController
        var controller = frameModule.topmost().ios.controller;

        // Access the UINavigationBar and change its barTintColorProperty
        controller.navigationBar.barTintColor = UIColor.redColor();

        // Call the UINavigationController's setNavigationBarHidden method
        controller.navigationBarHidden = false;
    }
};</code></pre>


<p>Here's what that red navigation bar looks like:</p>

<p><img src="http://tjvantoll.com/images/posts/2015-03-19/ios-red-nav-bar.png" class="plain" alt=""></p>

<p>Again, all that you're doing here is invoking iOS APIs with the NativeScript runtime. <code>controller.navigationBar</code> gets a reference to the app's <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html"><code>UINavigationBar</code></a>, and <code>navigationBar.barTintColor = UIColor.redColor()</code> changes its <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UINavigationBar_Class/index.html#//apple_ref/occ/instp/UINavigationBar/barTintColor"><code>barTintColor</code></a> property.</p>

<h2>What else can you do?</h2>

<p>Anything iOS allows you to do. Seriously. Obviously when you make these very iOS-specific changes some knowledge of iOS is required, and some knowledge of <a href="http://docs.nativescript.org/runtimes/ios/marshalling/Marshalling-Overview.html">how NativeScript handles marshalling between Objective-C and JavaScript</a> certainly helps, but I still think it's cool that you can access these native APIs so easily—in JavaScript even!</p>

<p>The appeal of NativeScript is that over time more and more of these common tasks are going to be abstracted into platform-agnostic modules so that you don't have to know the platform-specific details. <a href="https://github.com/nativescript/cross-platform-modules">There are already dozen of modules out there</a>, and new ones are being added with each release.</p>
]]></content>
  </entry>
  
</feed>
